# ====== RESOLUTION SWEEP (Leiden) with ARI + Recommendation ======
message("Step 2b: Leiden resolution sweep")

g_gc <- readRDS(file.path(output_dir, "editor_network_giant_igraph.rds"))
stopifnot(exists("res_sweep"), exists("leiden_iterations"))
sweep_repeats    <- if (exists("sweep_repeats")) sweep_repeats else 1
sweep_weight_mod <- if (exists("sweep_weight_mod")) sweep_weight_mod else 0.5
sweep_weight_ari <- if (exists("sweep_weight_ari")) sweep_weight_ari else 0.5

run_one <- function(res) { out <- leiden_modularity(g_gc, res = res, iters = leiden_iterations)
list(membership = as.integer(out$membership), modularity = as.numeric(out$modularity)) }

res_list <- vector("list", length(res_sweep)); names(res_list) <- as.character(res_sweep)
for (i in seq_along(res_sweep)) {
  res <- res_sweep[i]
  runs <- replicate(sweep_repeats, run_one(res), simplify = FALSE)
  modularities  <- vapply(runs, function(r) r$modularity, numeric(1))
  n_comms       <- vapply(runs, function(r) length(unique(r$membership)), integer(1))
  aris <- NA_real_
  if (length(runs) >= 2) {
    comb <- utils::combn(seq_along(runs), 2)
    aris <- apply(comb, 2, function(idx) adjusted_rand_index(runs[[idx[1]]]$membership, runs[[idx[2]]]$membership))
  }
  res_list[[i]] <- list(res=res, modularities=modularities, n_communities=n_comms, aris=aris)
}

res_results <- purrr::map_dfr(res_list, function(x) {
  tibble(
    resolution          = x$res,
    runs                = length(x$modularities),
    n_communities_mean  = mean(x$n_communities),
    n_communities_sd    = stats::sd(x$n_communities),
    modularity_mean     = mean(x$modularities),
    modularity_sd       = stats::sd(x$modularities),
    ari_mean            = if (all(is.na(x$aris))) NA_real_ else mean(x$aris, na.rm = TRUE),
    ari_sd              = if (all(is.na(x$aris))) NA_real_ else stats::sd(x$aris, na.rm = TRUE),
    ari_n_pairs         = if (all(is.na(x$aris))) 0L else length(x$aris)
  )
})

minmax <- function(v) {
  if (all(is.na(v))) return(rep(NA_real_, length(v)))
  rng <- range(v, na.rm = TRUE); if (diff(rng) == 0) return(rep(1, length(v)))
  (v - rng[1]) / (rng[2] - rng[1])
}
res_results <- res_results %>% mutate(
  mod_norm = minmax(modularity_mean),
  ari_norm = minmax(ari_mean),
  score    = sweep_weight_mod * mod_norm + sweep_weight_ari * ari_norm
)
best_row <- res_results %>% filter(!is.na(score)) %>% slice_max(score, n = 1, with_ties = FALSE)

if (nrow(best_row)) {
  recommendation <- best_row %>% transmute(
    resolution_recommended = resolution, score, modularity_mean, ari_mean, n_communities_mean, runs
  )
  message(sprintf("Recommended resolution: %s (score=%.3f; modularity=%.3f; ARI=%s; communities≈%.1f; runs=%d)",
                  format(recommendation$resolution_recommended, digits=3, nsmall=2),
                  recommendation$score, recommendation$modularity_mean,
                  ifelse(is.na(recommendation$ari_mean), "NA", sprintf("%.3f", recommendation$ari_mean)),
                  recommendation$n_communities_mean, recommendation$runs))
  saveRDS(recommendation, file.path(output_dir, "leiden_resolution_recommendation.rds"))
  readr::write_csv(recommendation, file.path(output_dir, "leiden_resolution_recommendation.csv"))
}

saveRDS(res_results, file.path(output_dir, "leiden_resolution_sweep_gc.rds"))
readr::write_csv(res_results, file.path(output_dir, "leiden_resolution_sweep_gc.csv"))

# Quick diagnostics
p_res_mod <- res_results %>% ggplot(aes(x=resolution, y=modularity_mean)) +
  geom_line() + geom_point() +
  geom_errorbar(aes(ymin = modularity_mean - modularity_sd, ymax = modularity_mean + modularity_sd),
                width = 0.02, alpha = 0.5) +
  geom_text(aes(label = round(n_communities_mean, 1)), vjust = -0.8, size = 3) +
  labs(title="Leiden Resolution Sweep — Modularity",
       subtitle="Labels: mean # communities; error bars: ±1 SD", x="Resolution", y="Modularity") +
  theme_minimal(base_family = "sans")

p_res_ari <- res_results %>% ggplot(aes(x=resolution, y=ari_mean)) +
  geom_line(na.rm=TRUE) + geom_point(na.rm=TRUE) +
  geom_errorbar(aes(ymin = ari_mean - ari_sd, ymax = ari_mean + ari_sd), width = 0.02, alpha = 0.5, na.rm=TRUE) +
  scale_y_continuous(limits = c(0,1), expand = expansion(mult=c(0.01,0.05))) +
  labs(title="Leiden Resolution Sweep — Stability (ARI)",
       subtitle="Higher = more stable across repeats; NA if repeats=1", x="Resolution", y="Mean ARI") +
  theme_minimal(base_family = "sans")

safe_plot(p_res_mod, file.path(output_dir, "plot_leiden_resolution_sweep_modularity.pdf"), 8, 6)
safe_plot(p_res_ari, file.path(output_dir, "plot_leiden_resolution_sweep_ari.pdf"),         8, 6)

message("Resolution sweep completed and saved.")
